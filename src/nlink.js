// Generated by CoffeeScript 1.3.1
(function() {
  var DEFINE, EMBED, EMPTY_NODE, IFDEF, IFNDEF, Linker, MACROS, MODULE, PRECOMPILE, REQUIRE, SANDBOX_ENV, SUB_EXT, TEMPLATE, argv, basename, coffee, define, defines, dirname, embed, existsSync, extname, freplace, fs, ifdef, inspect, join, jsp, linker, macros, makeDir, module, moduleNames, optimist, outdir, path, precompile, pro, readFileFromDirSync, removeCoffeeScriptHelpers, removeExt, replaceDefines, replaceFunctions, requires, runMacros, setExt, template, toplevel, vm, walkSync, _require, _wrapNamespace, _wrapRequireJs;

  optimist = require('optimist');

  vm = require('vm');

  fs = require('fs');

  path = require('path');

  Linker = require('./linker');

  coffee = require('coffee-script');

  jsp = require("uglify-js").parser;

  pro = require("uglify-js").uglify;

  EMPTY_NODE = ['name', ''];

  SUB_EXT = 'lib';

  PRECOMPILE = 'PRECOMPILE';

  EMBED = 'EMBED';

  TEMPLATE = 'PRECOMPILE_TEMPLATE';

  REQUIRE = 'require';

  MODULE = 'module';

  DEFINE = 'DEFINE';

  IFDEF = 'IFDEF';

  IFNDEF = 'IFNDEF';

  MACROS = 'MACROS';

  join = path.join, dirname = path.dirname, basename = path.basename, extname = path.extname, existsSync = path.existsSync;

  inspect = require('util').inspect;

  walkSync = require('fs.walker').walkSync;

  SANDBOX_ENV = {
    fs: fs,
    path: path,
    __dirname: __dirname,
    __filename: __filename
  };

  makeDir = function(path, options) {
    var mode, parent;
    if (options == null) {
      options = {};
    }
    mode = options.mode || 0x1ed;
    parent = dirname(path);
    if (!existsSync(parent)) {
      makeDir(parent, options);
    }
    if (!existsSync(path)) {
      fs.mkdirSync(path, mode);
      if (_.isArray(options.createdDirs)) {
        return options.createdDirs.push(path);
      }
    }
  };

  setExt = function(file, ext) {
    return file.replace(/(\.[^.\/]*)?$/i, ext);
  };

  removeExt = function(file, ext) {
    return file.replace(/(\.[^.\/]*)?$/i, '');
  };

  readFileFromDirSync = function(file, basedir, enc) {
    var old, result;
    old = null;
    if (basedir) {
      old = process.cwd();
      process.chdir(basedir);
    }
    path = fs.realpathSync(file);
    result = fs.readFileSync(path, enc);
    if (old) {
      process.chdir(old);
    }
    return result;
  };

  precompile = function(node, expr, args, options) {
    var code, obj, ret;
    if (expr[1] === PRECOMPILE) {
      code = pro.gen_code(args[0]);
      obj = vm.runInNewContext("" + code + "()", SANDBOX_ENV);
      ret = this.obj2ast(obj);
      return ret;
    }
  };

  macros = {};

  macros = function(node, expr, args, options) {
    var code;
    if (expr[1] === MACROS && args[0][0] === 'name') {
      code = pro.gen_code(args[1]);
      console.log(("" + args[0][1] + " = " + code).yellow);
      macros[args[0][1]] = code;
      console.log(macros);
      return EMPTY_NODE;
    }
  };

  runMacros = function(node, expr, args, options) {
    var a, str;
    if (expr[0] === 'name' && (macros[expr[1]] != null)) {
      a = args.map(this.walk);
      console.log('###'.green, macros[expr[1]]);
      console.log('###'.green, a.map(pro.gen_code).join(','));
      console.log(("(" + macros[expr[1]] + ")(" + (a.map(pro.gen_code).join(',')) + ")").green);
      console.log((str = vm.runInNewContext("(" + macros[expr[1]] + ")(" + (a.map(pro.gen_code).join(',')) + ")", SANDBOX_ENV)).red);
      return jsp.parse(str);
    }
  };

  embed = function(node, expr, args, options) {
    var code, embedDir, _ref;
    if (expr[1] === EMBED) {
      path = vm.runInNewContext(pro.gen_code(args[0]), SANDBOX_ENV);
      embedDir = (_ref = options.outdir) != null ? _ref : dirname(options.infile);
      code = readFileFromDirSync(path, embedDir, 'utf-8');
      return jsp.parse(code);
    }
  };

  template = function(node, expr, args, options) {
    var data, hogan, tplDir, _ref;
    if (expr[1] === TEMPLATE) {
      path = vm.runInNewContext(pro.gen_code(args[0]), SANDBOX_ENV);
      tplDir = (_ref = options.outdir) != null ? _ref : dirname(options.infile);
      console.log(tplDir.yellow, path);
      data = readFileFromDirSync(path, tplDir, 'utf-8');
      switch (extname(path)) {
        case '.mu':
        case '.mustache':
          hogan = require('hogan.js');
          template = hogan.compile(data, {
            asString: true
          });
          return this.fun2ast(template);
        default:
          return ['string', data];
      }
    }
  };

  requires = [];

  _require = function(node, expr, args, options) {
    var i, parent, ret, s, seg, _i, _len;
    if (expr[1] === REQUIRE) {
      path = vm.runInNewContext(pro.gen_code(args[0]), SANDBOX_ENV);
      requires.push(path);
      parent = this.parent();
      if (parent[0] === 'assign' || parent[0] === 'call') {
        seg = path.split('/');
        ret = ['name', seg[0]];
        for (i = _i = 0, _len = seg.length; _i < _len; i = ++_i) {
          s = seg[i];
          if (i === 0) {
            continue;
          }
          ret = ['dot', ret, s];
        }
        console.log('ret'.cyan, ret);
        return ret;
      } else {
        return EMPTY_NODE;
      }
    }
  };

  moduleNames = [];

  module = function(node, expr, args, options) {
    var name;
    if (expr[1] === MODULE) {
      name = vm.runInNewContext(pro.gen_code(args[0]), SANDBOX_ENV);
      moduleNames.push(name);
      return EMPTY_NODE;
    }
  };

  freplace = {
    '__extends': '$.inherit',
    '__hasProp': '$.hasProp',
    '__slice': '$.slice',
    '__bind': '$.bind',
    '__indexOf': '$.indexOf'
  };

  replaceFunctions = function(node, expr, args, options) {
    if (expr[0] === 'name' && (freplace[expr[1]] != null)) {
      expr[1] = freplace[expr[1]];
    }
    if (expr[0] === 'dot' && (expr[2] === 'call' || expr[2] === 'apply') && expr[1][0] === 'name' && (freplace[expr[1][1]] != null)) {
      expr[1][1] = freplace[expr[1][1]];
    }
  };

  removeCoffeeScriptHelpers = function(node, defs, options) {
    var def, newDef, walk, _i, _len;
    newDef = [];
    for (_i = 0, _len = defs.length; _i < _len; _i++) {
      def = defs[_i];
      if (!/__(hasProp|extends|indexOf|slice|bind)/.test(def[0])) {
        newDef.push(def);
      }
    }
    walk = this.walk;
    return [
      node[0], newDef.map(function(def) {
        var a;
        a = [def[0]];
        if (def.length > 1) {
          a[1] = walk(def[1]);
        }
        return a;
      })
    ];
  };

  defines = {};

  define = function(node, expr, args, options) {
    var _ref;
    if (expr[1] === DEFINE && args[0][0] === 'name') {
      defines[args[0][1]] = (_ref = this.walk(args[1])) != null ? _ref : ['name', ''];
      console.log('define'.magenta, inspect(args, false, null, true));
      return EMPTY_NODE;
    }
  };

  ifdef = function(node, expr, args, options) {
    var stats;
    if ((expr[1] === IFDEF) && args[0][0] === 'name') {
      if (defines[args[0][1]]) {
        stats = this.walk(args[1])[3];
        console.log('### ifdef'.green, stats);
        if (stats[stats.length - 1][0] === 'return') {
          stats[stats.length - 1][0] = 'stat';
        }
        return ['toplevel', stats];
      }
      return EMPTY_NODE;
    }
  };

  replaceDefines = function(node, name) {
    if (defines[name] != null) {
      console.log('replaceDefines'.magenta, name, '->', defines[name]);
    }
    if (defines[name] != null) {
      return defines[name];
    }
  };

  _wrapNamespace = function(ast, names) {
    var name, namesAst, _i, _len;
    namesAst = [];
    for (_i = 0, _len = names.length; _i < _len; _i++) {
      name = names[_i];
      namesAst.push(['string', name]);
    }
    return [['stat', ['call', ['name', '$.ns'], [['array', namesAst], ['function', null, ['exports'], ast]]]]];
  };

  _wrapRequireJs = function(ast, modules) {
    var modAst, module, _i, _len;
    modAst = [];
    for (_i = 0, _len = modules.length; _i < _len; _i++) {
      module = modules[_i];
      modAst.push(['string', module]);
    }
    return [['stat', ['call', ['name', 'define'], [['array', modAst], ['function', null, [], ast]]]]];
  };

  toplevel = function(node, statements, options) {
    var ret;
    moduleNames = [removeExt(options.path)];
    ret = statements.map(this.walk);
    console.log('toplevel'.magenta);
    if (!options.bare) {
      ret = _wrapNamespace(ret, moduleNames);
    }
    return [node[0], ret];
  };

  argv = require('optimist').usage('JS linker.\nUsage: nlink [TARGETS]').options('o', {
    alias: 'outdir',
    describe: 'Output dir'
  }).options('f', {
    boolean: true,
    alias: 'force',
    "default": false,
    describe: 'Force replace existing files'
  }).options('c', {
    boolean: true,
    alias: 'compress',
    "default": false,
    describe: 'Compress JavaScript'
  }).options('I', {
    alias: 'indent',
    "default": 2,
    describe: 'Set file indent'
  }).options('i', {
    alias: 'include',
    describe: 'Add include dir'
  }).options('b', {
    boolean: true,
    alias: 'bare',
    "default": false,
    describe: 'Skip wrap in namespace'
  }).options('v', {
    alias: 'version',
    describe: 'Show version'
  }).options('h', {
    alias: 'help',
    describe: 'Show help'
  }).argv;

  if (argv.h) {
    optimist.showHelp();
    return;
  }

  if (argv.v) {
    console.log('nlink v0.0.1');
    return;
  }

  if (argv.outdir) {
    outdir = fs.realpathSync(argv.outdir);
  }

  linker = new Linker({
    compress: argv.compress,
    indent: argv.indent
  });

  linker.on('call::name', precompile);

  linker.on('call::name', define);

  linker.on('call::name', ifdef);

  linker.on('call::name', template);

  linker.on('call::name', embed);

  linker.on('call::name', _require);

  linker.on('call::name', module);

  linker.on('call::name', macros);

  linker.on('call::name', runMacros);

  linker.on('var', removeCoffeeScriptHelpers);

  linker.on('call', replaceFunctions);

  linker.on('name', replaceDefines);

  linker.on('toplevel', toplevel);

  walkSync().set({
    relative: '.'
  }).on('file', function(path, ctx) {
    var base, code, infile, outfile;
    infile = path;
    code = void 0;
    console.log(infile.green);
    if (ctx.extname() === '.coffee') {
      code = fs.readFileSync(infile, 'utf-8');
      code = coffee.compile(code, {
        bare: true
      });
    }
    if (ctx.extname() === '.js') {
      code = fs.readFileSync(infile, 'utf-8');
    }
    if (!code) {
      return;
    }
    console.log(ctx.subpath());
    outfile = outdir ? join(outdir, ctx.subpath(), ctx.basename(false) + '.js') : (base = join(ctx.dirname(), ctx.basename(false)), !existsSync("" + base + ".js") || argv.force ? "" + base + ".js" : "" + base + "." + SUB_EXT + ".js");
    console.log(outfile.cyan, '\n');
    code = linker.link(code, {
      infile: infile,
      outfile: outfile,
      path: ctx.relpath(),
      outdir: outdir,
      bare: argv.b
    });
    return fs.writeFileSync(outfile, code, 'utf-8');
  }).on('dir', function(path, ctx) {
    console.log(path.magenta);
    if (path === outdir) {
      throw 'continue';
    }
  }).walk(argv._);

}).call(this);
