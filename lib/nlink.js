// Generated by CoffeeScript 1.3.1
(function() {
  var DEFINE, EMBED, EMPTY_NODE, IFDEF, IFNDEF, Linker, MACROS, MODULE, PRECOMPILE, REQUIRE, SANDBOX_ENV, SCRIPT_FILES, TEMPLATE, basename, coffee, define, defines, dirname, embed, existsSync, extname, freplace, fs, ifdef, indexIncludes, inspect, isArray, join, jsp, macros, makeDir, moduleNames, nlink, normalize, path, precompile, pro, readFileFromDirSync, relative, removeCoffeeScriptHelpers, removeExt, replaceDefines, replaceFunctions, requires, runMacros, setExt, template, toplevel, vm, walkSync, _module, _require, _wrapNamespace, _wrapRequireJs,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  vm = require('vm');

  fs = require('fs');

  path = require('path');

  Linker = require('./linker');

  coffee = require('coffee-script');

  jsp = require("uglify-js").parser;

  pro = require("uglify-js").uglify;

  join = path.join, dirname = path.dirname, basename = path.basename, extname = path.extname, existsSync = path.existsSync, normalize = path.normalize, relative = path.relative;

  inspect = require('util').inspect;

  walkSync = require('fs.walker').walkSync;

  EMPTY_NODE = ['name', ''];

  PRECOMPILE = 'PRECOMPILE';

  EMBED = 'EMBED';

  TEMPLATE = 'PRECOMPILE_TEMPLATE';

  DEFINE = 'DEFINE';

  IFDEF = 'IFDEF';

  IFNDEF = 'IFNDEF';

  MACROS = 'MACROS';

  REQUIRE = 'require';

  MODULE = 'module';

  SCRIPT_FILES = ['njs', 'js', 'coffee'];

  SANDBOX_ENV = {
    fs: fs,
    path: path,
    __dirname: __dirname,
    __filename: __filename
  };

  isArray = Array.isArray;

  makeDir = function(path, options) {
    var mode, parent;
    if (options == null) {
      options = {};
    }
    mode = options.mode || 0x1ed;
    parent = dirname(path);
    if (!existsSync(parent)) {
      makeDir(parent, options);
    }
    if (!existsSync(path)) {
      fs.mkdirSync(path, mode);
      if (isArray(options.createdDirs)) {
        return options.createdDirs.push(path);
      }
    }
  };

  setExt = function(file, ext) {
    return file.replace(/(\.[^.\/]*)?$/i, ext);
  };

  removeExt = function(file, ext) {
    return file.replace(/(\.[^.\/]*)?$/i, '');
  };

  indexIncludes = function(dirs) {
    var add, index;
    index = {};
    add = function(name, type, path, dir) {
      if (dir == null) {
        dir = false;
      }
      return index[name] = {
        name: name,
        type: type,
        path: path,
        dir: dir
      };
    };
    walkSync().on('file', function(path, ctx) {
      var name, _ref;
      name = join(ctx.subpath(), ctx.basename());
      if (!index[name]) {
        add(name, ctx.extname(false), path);
        if (_ref = ctx.extname(false), __indexOf.call(SCRIPT_FILES, _ref) >= 0) {
          name = join(ctx.subpath(), ctx.basename(false));
          if (index[name] && SCRIPT_FILES.indexOf(index[name].type) > SCRIPT_FILES.indexOf(ctx.extname(false))) {
            index[name].type = ctx.extname(false);
            index[name].path = path;
          } else {
            add(name, ctx.extname(false), path);
          }
          if (ctx.basename() === 'index') {
            name = ctx.subpath();
            if (index[name] && index[name].dir && SCRIPT_FILES.indexOf(index[name].type) > SCRIPT_FILES.indexOf(ctx.extname(false))) {
              index[name].type = ctx.extname(false);
              return index[name].path = path;
            } else {
              return add(name, ctx.extname(false), path, true);
            }
          }
        }
      }
    }).walk(dirs);
    return index;
  };

  readFileFromDirSync = function(file, basedir, enc) {
    var old, result;
    old = null;
    if (basedir) {
      old = process.cwd();
      process.chdir(basedir);
    }
    path = fs.realpathSync(file);
    result = fs.readFileSync(path, enc);
    if (old) {
      process.chdir(old);
    }
    return result;
  };

  precompile = function(node, expr, args, options) {
    var code, obj, ret;
    if (expr[1] === PRECOMPILE) {
      code = pro.gen_code(args[0]);
      obj = vm.runInNewContext("" + code + "()", SANDBOX_ENV);
      ret = this.obj2ast(obj);
      return ret;
    }
  };

  macros = {};

  macros = function(node, expr, args, options) {
    var code;
    if (expr[1] === MACROS && args[0][0] === 'name') {
      code = pro.gen_code(args[1]);
      macros[args[0][1]] = code;
      return EMPTY_NODE;
    }
  };

  runMacros = function(node, expr, args, options) {
    var a, str;
    if (expr[0] === 'name' && (macros[expr[1]] != null)) {
      a = args.map(this.walk);
      str = vm.runInNewContext("(" + macros[expr[1]] + ")(" + (a.map(pro.gen_code).join(',')) + ")", SANDBOX_ENV);
      return jsp.parse(str);
    }
  };

  embed = function(node, expr, args, options) {
    var code;
    if (expr[1] === EMBED) {
      path = vm.runInNewContext(pro.gen_code(args[0]), SANDBOX_ENV);
      code = fs.readFileSync(options.fscope[normalize(path)].path, 'utf-8');
      return jsp.parse(code);
    }
  };

  template = function(node, expr, args, options) {
    var data, hogan;
    if (expr[1] === TEMPLATE) {
      path = vm.runInNewContext(pro.gen_code(args[0]), SANDBOX_ENV);
      data = fs.readFileSync(options.fscope[normalize(path)].path, 'utf-8');
      switch (extname(path)) {
        case '.mu':
        case '.mustache':
          hogan = require('hogan.js');
          template = hogan.compile(data, {
            asString: true
          });
          return this.fun2ast(template);
        default:
          return ['string', data];
      }
    }
  };

  requires = [];

  _require = function(node, expr, args, options) {
    if (expr[1] === REQUIRE) {
      path = vm.runInNewContext(pro.gen_code(args[0]), SANDBOX_ENV);
      requires.push(path);
    }
  };

  moduleNames = [];

  _module = function(node, expr, args, options) {
    var name;
    if (expr[1] === MODULE) {
      name = vm.runInNewContext(pro.gen_code(args[0]), SANDBOX_ENV);
      moduleNames.push(name);
      return EMPTY_NODE;
    }
  };

  freplace = {
    '__extends': '$.inherit',
    '__hasProp': '$.hasProp',
    '__slice': '$.slice',
    '__bind': '$.bind',
    '__indexOf': '$.indexOf'
  };

  replaceFunctions = function(node, expr, args, options) {
    if (expr[0] === 'name' && (freplace[expr[1]] != null)) {
      expr[1] = freplace[expr[1]];
    }
    if (expr[0] === 'dot' && (expr[2] === 'call' || expr[2] === 'apply') && expr[1][0] === 'name' && (freplace[expr[1][1]] != null)) {
      expr[1][1] = freplace[expr[1][1]];
    }
  };

  removeCoffeeScriptHelpers = function(node, defs, options) {
    var def, newDef, walk, _i, _len;
    newDef = [];
    for (_i = 0, _len = defs.length; _i < _len; _i++) {
      def = defs[_i];
      if (!/__(hasProp|extends|indexOf|slice|bind)/.test(def[0])) {
        newDef.push(def);
      }
    }
    walk = this.walk;
    return [
      node[0], newDef.map(function(def) {
        var a;
        a = [def[0]];
        if (def.length > 1) {
          a[1] = walk(def[1]);
        }
        return a;
      })
    ];
  };

  defines = {};

  define = function(node, expr, args, options) {
    var _ref;
    if (expr[1] === DEFINE && args[0][0] === 'name') {
      defines[args[0][1]] = (_ref = this.walk(args[1])) != null ? _ref : ['name', ''];
      return EMPTY_NODE;
    }
  };

  ifdef = function(node, expr, args, options) {
    var stats;
    if ((expr[1] === IFDEF) && args[0][0] === 'name') {
      if (defines[args[0][1]]) {
        stats = this.walk(args[1])[3];
        if (stats[stats.length - 1][0] === 'return') {
          stats[stats.length - 1][0] = 'stat';
        }
        return ['toplevel', stats];
      }
      return EMPTY_NODE;
    }
  };

  replaceDefines = function(node, name) {
    if (defines[name] != null) {
      return defines[name];
    }
  };

  _wrapNamespace = function(ast, names) {
    var name, namesAst, _i, _len;
    namesAst = [];
    for (_i = 0, _len = names.length; _i < _len; _i++) {
      name = names[_i];
      namesAst.push(['string', name]);
    }
    return [['stat', ['call', ['name', '$.ns'], [['array', namesAst], ['function', null, ['exports'], ast]]]]];
  };

  _wrapRequireJs = function(ast, modules) {
    var modAst, module, _i, _len;
    modAst = [];
    for (_i = 0, _len = modules.length; _i < _len; _i++) {
      module = modules[_i];
      modAst.push(['string', module]);
    }
    return [['stat', ['call', ['name', 'define'], [['array', modAst], ['function', null, [], ast]]]]];
  };

  toplevel = function(node, statements, options) {
    var ret;
    moduleNames = [removeExt(options.path)];
    ret = statements.map(this.walk);
    if (!options.bare) {
      ret = _wrapNamespace(ret, moduleNames);
    }
    return [node[0], ret];
  };

  nlink = function(targets, options) {
    var baseDir, count, globalScope, includes, linker, outdir, _ref;
    if (!targets) {
      return;
    }
    if (options.outdir) {
      outdir = fs.realpathSync(options.outdir);
    }
    linker = new Linker({
      compress: options.compress,
      indent: options.indent
    });
    linker.on('call::name', precompile);
    linker.on('call::name', define);
    linker.on('call::name', ifdef);
    linker.on('call::name', template);
    linker.on('call::name', embed);
    linker.on('call::name', _require);
    linker.on('call::name', _module);
    linker.on('call::name', macros);
    linker.on('call::name', runMacros);
    linker.on('var', removeCoffeeScriptHelpers);
    linker.on('call', replaceFunctions);
    linker.on('name', replaceDefines);
    linker.on('toplevel', toplevel);
    includes = [];
    if (options.include != null) {
      if (isArray(options.include)) {
        includes = includes.concat(options.include);
      } else {
        includes.push(options.include);
      }
    }
    globalScope = indexIncludes(includes);
    baseDir = (_ref = options.basedir) != null ? _ref : '.';
    count = 0;
    walkSync().set({
      relative: baseDir
    }).on('file', function(path, ctx) {
      var base, code, fscope, infile, outfile;
      infile = path;
      code = void 0;
      if (ctx.extname() === '.coffee') {
        code = fs.readFileSync(infile, 'utf-8');
        code = coffee.compile(code, {
          bare: true
        });
      }
      if (ctx.extname() === '.js') {
        code = fs.readFileSync(infile, 'utf-8');
      }
      if (!code) {
        return;
      }
      outfile = outdir ? join(outdir, ctx.subpath(), ctx.basename(false) + '.js') : (base = join(ctx.dirname(), ctx.basename(false)), !existsSync("" + base + ".js") || options.force ? "" + base + ".js" : "" + base + ".njs");
      fscope = __extends(globalScope, indexIncludes([dirname(infile)]));
      makeDir(dirname(outfile));
      code = linker.link(code, {
        infile: infile,
        outfile: outfile,
        path: ctx.relpath(),
        outdir: outdir,
        bare: options.bare,
        fscope: fscope
      });
      console.log(("link " + (ctx.relpath()) + " -> " + (relative(baseDir, outfile))).green);
      fs.writeFileSync(outfile, code, 'utf-8');
      return count++;
    }).on('dir', function(path, ctx) {
      if (path === outdir) {
        throw 'continue';
      }
    }).walk(targets);
    return console.log(("" + count + " files successfully linker").cyan);
  };

  nlink.VERSION = "0.0.2";

  module.exports = nlink;

}).call(this);
